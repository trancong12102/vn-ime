# event-handling Specification

## Purpose
Defines the keyboard event handling system using CGEventTap for system-wide keyboard interception, text injection, hotkey handling, and application compatibility.
## Requirements
### Requirement: Keyboard Event Interception

The system SHALL intercept keyboard events system-wide using macOS CGEventTap.

#### Scenario: Event tap initialization
- **WHEN** application starts
- **AND** accessibility permissions are granted
- **THEN** CGEventTap is created for keyboard and mouse events
- **AND** a private CGEventSource is created for own-event identification

#### Scenario: Event capture
- **WHEN** user presses a key in any application
- **THEN** the event is captured by VnIme before reaching the target application

#### Scenario: Own event filtering
- **WHEN** an event is generated by VnIme itself
- **THEN** the event is passed through without processing
- **AND** infinite loops are prevented by comparing source state IDs

#### Scenario: Event tap recovery
- **WHEN** event tap is disabled by system timeout
- **THEN** the tap is automatically re-enabled

#### Scenario: Mouse event detection
- **WHEN** a mouse click or drag event occurs
- **THEN** the event is detected by the event tap
- **AND** the event is passed through unchanged after session reset

---

### Requirement: Keyboard Event Processing

The system SHALL process keyboard events and determine appropriate action.

#### Scenario: Vietnamese mode key processing
- **WHEN** Vietnamese mode is active
- **AND** a key is pressed without control modifiers (except Shift)
- **THEN** the key is sent to Vietnamese engine for processing

#### Scenario: English mode passthrough
- **WHEN** English mode is active
- **AND** a key is pressed
- **THEN** the key is passed through unchanged

#### Scenario: Mouse event session reset
- **WHEN** a mouse click or drag event occurs
- **THEN** current typing session is reset via engine
- **AND** typing buffer is cleared

#### Scenario: Other control key bypass
- **WHEN** a key is pressed with Command, Control, or Option modifier
- **THEN** the key is passed through unchanged
- **AND** Vietnamese processing is skipped

#### Scenario: Temporary engine disable
- **WHEN** Command key is held down
- **THEN** Vietnamese processing is temporarily bypassed
- **AND** all keys pass through unchanged until Command is released

#### Scenario: Break keycode session reset
- **WHEN** a navigation break keycode is detected (ESC, arrows, Tab, Enter)
- **THEN** current typing session is reset via engine
- **AND** typing buffer is cleared
- **AND** the key event is passed through to the application

### Requirement: Text Output Injection

The system SHALL inject processed text back to applications using CGEventTapPostEvent.

#### Scenario: Backspace injection
- **WHEN** Vietnamese processing requires character replacement
- **THEN** appropriate number of backspace events are sent first
- **AND** events are created with private event source
- **AND** events are posted via CGEventTapPostEvent for reliability

#### Scenario: Unicode character injection (batch mode)
- **WHEN** new characters need to be output
- **AND** batch mode is enabled (default)
- **THEN** up to 16 Unicode characters are injected per event
- **AND** strings longer than 16 chars are sent in multiple batches

#### Scenario: Unicode character injection (step-by-step mode)
- **WHEN** new characters need to be output
- **AND** step-by-step mode is enabled
- **THEN** each character is injected as a separate keyboard event

#### Scenario: Empty character injection
- **WHEN** application requires special handling for autocomplete
- **THEN** appropriate empty character is injected before backspaces
- **AND** NNBSP (0x202F) is used by default
- **AND** ZWNJ (0x200C) is used for Sublime Text

---

### Requirement: Hotkey Handling

The system SHALL respond to configurable hotkeys.

#### Scenario: Language switch hotkey
- **WHEN** user presses language switch hotkey (default: Option+Z)
- **THEN** input language toggles between Vietnamese and English
- **AND** optional beep sound is played

#### Scenario: Hotkey customization
- **WHEN** user configures custom hotkey in settings
- **THEN** the new hotkey is recognized using bitfield format

#### Scenario: Hotkey event consumption
- **WHEN** a hotkey is matched
- **THEN** the event is consumed (not passed to application)

---

### Requirement: Application Compatibility

The system SHALL handle application-specific quirks for compatibility.

#### Scenario: Browser autocomplete handling
- **WHEN** typing in Chrome, Safari, or other browsers
- **AND** autocomplete may interfere
- **THEN** empty character is injected before backspaces

#### Scenario: Sublime Text compatibility
- **WHEN** typing in Sublime Text
- **THEN** ZWNJ (0x200C) is used instead of NNBSP for empty character

#### Scenario: Chromium browser workaround
- **WHEN** typing in Chrome, Brave, or Edge
- **AND** standard backspace has issues
- **THEN** Shift+Left Arrow method is used to select characters
- **AND** selected text is replaced by new characters

#### Scenario: Application detection
- **WHEN** frontmost application changes
- **THEN** bundle identifier is detected via NSWorkspace
- **AND** appropriate quirk handling is selected based on prefix matching

---

### Requirement: Accessibility Permission Management

The system SHALL manage accessibility permissions properly.

#### Scenario: Permission check on startup
- **WHEN** application starts
- **THEN** accessibility permission status is checked via AXIsProcessTrusted()

#### Scenario: Permission not granted
- **WHEN** accessibility permission is not granted
- **THEN** user is shown permission request dialog
- **AND** dialog includes button to open System Settings
- **AND** application cannot process keyboard events until granted

#### Scenario: Permission granted
- **WHEN** accessibility permission is granted
- **THEN** event tap is initialized and keyboard processing begins

---

### Requirement: Keyboard Layout Compatibility

The system SHALL support different keyboard layouts.

#### Scenario: Layout conversion
- **WHEN** keyboard layout compatibility is enabled
- **AND** non-QWERTY layout is detected
- **THEN** physical key codes are converted to logical characters
- **AND** NSEvent.charactersIgnoringModifiers is used for mapping

#### Scenario: Layout-independent operation
- **WHEN** user switches keyboard layout
- **THEN** Vietnamese input continues to work correctly
- **AND** fallback to physical key code is used if mapping fails

---

### Requirement: Text Injector Component

The system SHALL provide a dedicated component for text injection with application-aware behavior.

#### Scenario: Injector initialization
- **WHEN** KeyboardEventHandler is created
- **THEN** TextInjector is initialized with private event source
- **AND** pre-created backspace events are prepared for performance

#### Scenario: App-specific injection
- **WHEN** text needs to be injected
- **THEN** TextInjector checks current application bundle ID
- **AND** applies appropriate injection method based on quirk registry

#### Scenario: Quirk registry lookup
- **WHEN** injection method is needed
- **THEN** application bundle ID is matched against known quirks
- **AND** prefix matching is used for flexibility
- **AND** default behavior is used for unknown applications

---

### Requirement: Other Language Input Source Detection

The system SHALL detect and respect other language input methods.

#### Scenario: Input source check
- **WHEN** keyboard event is received
- **AND** other language bypass is enabled
- **THEN** current system input source language is checked via TIS

#### Scenario: Non-English input source active
- **WHEN** a non-English input method is active (Japanese, Chinese, Korean, etc.)
- **THEN** Vietnamese processing is bypassed
- **AND** all keyboard events pass through unchanged

#### Scenario: English input source active
- **WHEN** English input source is active
- **THEN** normal Vietnamese processing proceeds

---

### Requirement: Modifier Key Tracking

The system SHALL track modifier key states for proper processing.

#### Scenario: Modifier extraction
- **WHEN** keyboard event is received
- **THEN** modifier flags are extracted (Shift, Control, Command, Option, Caps Lock)

#### Scenario: Caps status detection
- **WHEN** determining character capitalization
- **THEN** Shift key results in capsStatus = 1
- **AND** Caps Lock results in capsStatus = 2
- **AND** capsStatus is passed to engine for proper character generation

#### Scenario: FlagsChanged event handling
- **WHEN** modifier key state changes
- **THEN** event is processed for hotkey detection
- **AND** temporary disable states are updated

### Requirement: Break Keycode Detection

The system SHALL detect navigation keys by keycode and reset the typing session, independent of character-based word break detection.

#### Scenario: ESC key resets session
- **WHEN** user presses ESC key (keycode 53)
- **THEN** restore-if-wrong-spelling is checked first
- **AND** the typing buffer is cleared via engine reset
- **AND** the ESC key event is passed through to the application
- **AND** no Vietnamese character processing occurs

#### Scenario: Arrow keys reset session
- **WHEN** user presses any arrow key (Left=123, Right=124, Down=125, Up=126)
- **THEN** the typing buffer is cleared via engine reset
- **AND** the arrow key event is passed through to the application

#### Scenario: Tab key resets session
- **WHEN** user presses Tab key (keycode 48)
- **THEN** the typing buffer is cleared via engine reset
- **AND** the Tab key event is passed through to the application

#### Scenario: Enter/Return keys reset session
- **WHEN** user presses Enter (keycode 76) or Return (keycode 36)
- **THEN** the typing buffer is cleared via engine reset
- **AND** the key event is passed through to the application

#### Scenario: Break keycode takes priority over character
- **WHEN** a key has both a break keycode and produces a character
- **THEN** the keycode check happens first
- **AND** session is reset before any character processing

---

### Requirement: Break Keycode Constants

The system SHALL define platform-specific virtual key codes for session-breaking keys.

#### Scenario: macOS navigation key codes
- **WHEN** the system needs to identify break keycodes on macOS
- **THEN** the following virtual key codes are recognized:
  - ESC = 53
  - Tab = 48
  - Return = 36
  - Enter = 76 (numpad)
  - Left Arrow = 123
  - Right Arrow = 124
  - Down Arrow = 125
  - Up Arrow = 126

#### Scenario: Backspace is not a break keycode
- **WHEN** user presses Backspace (keycode 51)
- **THEN** it is NOT treated as a break keycode
- **AND** dedicated backspace handling logic is used instead

---

